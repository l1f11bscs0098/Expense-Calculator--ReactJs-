{"ast":null,"code":"'use strict';\n\n// like String.prototype.search but returns the last index\nfunction _searchLast(str, rgx) {\n  const matches = Array.from(str.matchAll(rgx));\n  return matches.length > 0 ? matches.slice(-1)[0].index : -1;\n}\nfunction _interpolate(envValue, environment, config) {\n  // find the last unescaped dollar sign in the\n  // value so that we can evaluate it\n  const lastUnescapedDollarSignIndex = _searchLast(envValue, /(?!(?<=\\\\))\\$/g);\n\n  // If we couldn't match any unescaped dollar sign\n  // let's return the string as is\n  if (lastUnescapedDollarSignIndex === -1) return envValue;\n\n  // This is the right-most group of variables in the string\n  const rightMostGroup = envValue.slice(lastUnescapedDollarSignIndex);\n\n  /**\n   * This finds the inner most variable/group divided\n   * by variable name and default value (if present)\n   * (\n   *   (?!(?<=\\\\))\\$        // only match dollar signs that are not escaped\n   *   {?                   // optional opening curly brace\n   *     ([\\w]+)            // match the variable name\n   *     (?::-([^}\\\\]*))?   // match an optional default value\n   *   }?                   // optional closing curly brace\n   * )\n   */\n  const matchGroup = /((?!(?<=\\\\))\\${?([\\w]+)(?::-([^}\\\\]*))?}?)/;\n  const match = rightMostGroup.match(matchGroup);\n  if (match != null) {\n    const [, group, variableName, defaultValue] = match;\n    return _interpolate(envValue.replace(group, environment[variableName] || defaultValue || config.parsed[variableName] || ''), environment, config);\n  }\n  return envValue;\n}\nfunction _resolveEscapeSequences(value) {\n  return value.replace(/\\\\\\$/g, '$');\n}\nfunction expand(config) {\n  // if ignoring process.env, use a blank object\n  const environment = config.ignoreProcessEnv ? {} : process.env;\n  for (const configKey in config.parsed) {\n    const value = Object.prototype.hasOwnProperty.call(environment, configKey) ? environment[configKey] : config.parsed[configKey];\n    config.parsed[configKey] = _resolveEscapeSequences(_interpolate(value, environment, config));\n  }\n  for (const processKey in config.parsed) {\n    environment[processKey] = config.parsed[processKey];\n  }\n  return config;\n}\nmodule.exports.expand = expand;","map":{"version":3,"names":["_searchLast","str","rgx","matches","Array","from","matchAll","length","slice","index","_interpolate","envValue","environment","config","lastUnescapedDollarSignIndex","rightMostGroup","matchGroup","match","group","variableName","defaultValue","replace","parsed","_resolveEscapeSequences","value","expand","ignoreProcessEnv","process","env","configKey","Object","prototype","hasOwnProperty","call","processKey","module","exports"],"sources":["C:/xampp/htdocs/expense_calculator/node_modules/dotenv-expand/lib/main.js"],"sourcesContent":["'use strict'\n\n// like String.prototype.search but returns the last index\nfunction _searchLast (str, rgx) {\n  const matches = Array.from(str.matchAll(rgx))\n  return matches.length > 0 ? matches.slice(-1)[0].index : -1\n}\n\nfunction _interpolate (envValue, environment, config) {\n  // find the last unescaped dollar sign in the\n  // value so that we can evaluate it\n  const lastUnescapedDollarSignIndex = _searchLast(envValue, /(?!(?<=\\\\))\\$/g)\n\n  // If we couldn't match any unescaped dollar sign\n  // let's return the string as is\n  if (lastUnescapedDollarSignIndex === -1) return envValue\n\n  // This is the right-most group of variables in the string\n  const rightMostGroup = envValue.slice(lastUnescapedDollarSignIndex)\n\n  /**\n   * This finds the inner most variable/group divided\n   * by variable name and default value (if present)\n   * (\n   *   (?!(?<=\\\\))\\$        // only match dollar signs that are not escaped\n   *   {?                   // optional opening curly brace\n   *     ([\\w]+)            // match the variable name\n   *     (?::-([^}\\\\]*))?   // match an optional default value\n   *   }?                   // optional closing curly brace\n   * )\n   */\n  const matchGroup = /((?!(?<=\\\\))\\${?([\\w]+)(?::-([^}\\\\]*))?}?)/\n  const match = rightMostGroup.match(matchGroup)\n\n  if (match != null) {\n    const [, group, variableName, defaultValue] = match\n\n    return _interpolate(\n      envValue.replace(\n        group,\n        environment[variableName] ||\n          defaultValue ||\n          config.parsed[variableName] ||\n          ''\n      ),\n      environment,\n      config\n    )\n  }\n\n  return envValue\n}\n\nfunction _resolveEscapeSequences (value) {\n  return value.replace(/\\\\\\$/g, '$')\n}\n\nfunction expand (config) {\n  // if ignoring process.env, use a blank object\n  const environment = config.ignoreProcessEnv ? {} : process.env\n\n  for (const configKey in config.parsed) {\n    const value = Object.prototype.hasOwnProperty.call(environment, configKey)\n      ? environment[configKey]\n      : config.parsed[configKey]\n\n    config.parsed[configKey] = _resolveEscapeSequences(\n      _interpolate(value, environment, config)\n    )\n  }\n\n  for (const processKey in config.parsed) {\n    environment[processKey] = config.parsed[processKey]\n  }\n\n  return config\n}\n\nmodule.exports.expand = expand\n"],"mappings":"AAAA,YAAY;;AAEZ;AACA,SAASA,WAAWA,CAAEC,GAAG,EAAEC,GAAG,EAAE;EAC9B,MAAMC,OAAO,GAAGC,KAAK,CAACC,IAAI,CAACJ,GAAG,CAACK,QAAQ,CAACJ,GAAG,CAAC,CAAC;EAC7C,OAAOC,OAAO,CAACI,MAAM,GAAG,CAAC,GAAGJ,OAAO,CAACK,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAACC,KAAK,GAAG,CAAC,CAAC;AAC7D;AAEA,SAASC,YAAYA,CAAEC,QAAQ,EAAEC,WAAW,EAAEC,MAAM,EAAE;EACpD;EACA;EACA,MAAMC,4BAA4B,GAAGd,WAAW,CAACW,QAAQ,EAAE,gBAAgB,CAAC;;EAE5E;EACA;EACA,IAAIG,4BAA4B,KAAK,CAAC,CAAC,EAAE,OAAOH,QAAQ;;EAExD;EACA,MAAMI,cAAc,GAAGJ,QAAQ,CAACH,KAAK,CAACM,4BAA4B,CAAC;;EAEnE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAME,UAAU,GAAG,4CAA4C;EAC/D,MAAMC,KAAK,GAAGF,cAAc,CAACE,KAAK,CAACD,UAAU,CAAC;EAE9C,IAAIC,KAAK,IAAI,IAAI,EAAE;IACjB,MAAM,GAAGC,KAAK,EAAEC,YAAY,EAAEC,YAAY,CAAC,GAAGH,KAAK;IAEnD,OAAOP,YAAY,CACjBC,QAAQ,CAACU,OAAO,CACdH,KAAK,EACLN,WAAW,CAACO,YAAY,CAAC,IACvBC,YAAY,IACZP,MAAM,CAACS,MAAM,CAACH,YAAY,CAAC,IAC3B,EACJ,CAAC,EACDP,WAAW,EACXC,MACF,CAAC;EACH;EAEA,OAAOF,QAAQ;AACjB;AAEA,SAASY,uBAAuBA,CAAEC,KAAK,EAAE;EACvC,OAAOA,KAAK,CAACH,OAAO,CAAC,OAAO,EAAE,GAAG,CAAC;AACpC;AAEA,SAASI,MAAMA,CAAEZ,MAAM,EAAE;EACvB;EACA,MAAMD,WAAW,GAAGC,MAAM,CAACa,gBAAgB,GAAG,CAAC,CAAC,GAAGC,OAAO,CAACC,GAAG;EAE9D,KAAK,MAAMC,SAAS,IAAIhB,MAAM,CAACS,MAAM,EAAE;IACrC,MAAME,KAAK,GAAGM,MAAM,CAACC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACrB,WAAW,EAAEiB,SAAS,CAAC,GACtEjB,WAAW,CAACiB,SAAS,CAAC,GACtBhB,MAAM,CAACS,MAAM,CAACO,SAAS,CAAC;IAE5BhB,MAAM,CAACS,MAAM,CAACO,SAAS,CAAC,GAAGN,uBAAuB,CAChDb,YAAY,CAACc,KAAK,EAAEZ,WAAW,EAAEC,MAAM,CACzC,CAAC;EACH;EAEA,KAAK,MAAMqB,UAAU,IAAIrB,MAAM,CAACS,MAAM,EAAE;IACtCV,WAAW,CAACsB,UAAU,CAAC,GAAGrB,MAAM,CAACS,MAAM,CAACY,UAAU,CAAC;EACrD;EAEA,OAAOrB,MAAM;AACf;AAEAsB,MAAM,CAACC,OAAO,CAACX,MAAM,GAAGA,MAAM"},"metadata":{},"sourceType":"script","externalDependencies":[]}